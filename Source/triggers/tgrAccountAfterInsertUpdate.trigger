/*
    @Author: mkha@yousee.dk and wm@yousee.dk
    Test-class: clsAccountTest

    Permission Check section added by kamih@yousee.dk
    Test-class: clsPermissionCheckTest

    Scope: This trigger is fired before inserting and updating contacts. 
    
    Tasks:
    T1. If the customer is of type hierarchy and if KISS_Customer_No__c is null, then copy the value of Salesforce id into KISS_Customer_No__c (YS project) - See SF-230
    T2. If the customer is of type hierarchy and if Customer_No__c is null, then copy the value of Salesforce id into Customer_No__c (YS project) - See SF-230
    T3. Ensures that SuperiorAccount is updated on child accounts when a customer is reparented in various scenarios. (Service-Center project)
    T4. If a new customer is added with a parent reference and if that new parent is portal-active then copy existing user related roles to new account. This ensures that 
        existing users and portal users are automatically granted access to the new cable unit or hierarchy account in portal (Service-Center project)
    
    Bypass:
    B1. Cast Iron bypasses most of the logic except mandatory tasks. The bypass is implemented for performance purposes since the validation is aimed at end users. 
*/
trigger tgrAccountAfterInsertUpdate on Account (after insert, after update) {
    //B1. Retrieve ID for Cast Iron User for bypassing validation. commented for SF-1364 issues
    //public static User CastIron = [Select ID from User where Name= 'CI CastIron' limit 1];
    private static ID userDataLoadId = ServiceCenter_CustomSettings__c.getInstance('UserDataloadNoOutboundId') != null ? ServiceCenter_CustomSettings__c.getInstance('UserDataloadNoOutboundId').Value__c : null;
    private static ID userCIId = ServiceCenter_CustomSettings__c.getInstance('UserCIID') != null ? ServiceCenter_CustomSettings__c.getInstance('UserCIID').Value__c : null;
    private static ID userAPIId = ServiceCenter_CustomSettings__c.getInstance('UserAPINOId') != null ? ServiceCenter_CustomSettings__c.getInstance('UserAPINOId').Value__c : null;
    
    // Code Changes for SF-1364
    /*Set<Id> userset = new Set<Id>();
	List<User> userList = new List<User>();
    
    userList = [Select Id, Name From User where Name = 'API No Outbound User' or Name = 'Dataload No Outbound User' or Name = 'CI CastIron' limit 3];
	System.debug('#########UserList Details'+userList+'####Size'+userList.size());
	for(User us : userList){
	    userset.add(us.Id);
	}*/
	
    Set<Id> businessCustomers = new Set<Id>();
    for(Account acc: Trigger.new) {
        //Collecting necessary ids for validation purposes - business customers only
        if(!businessCustomers.contains(acc.Id) && acc.IsPersonAccount == false)
            businessCustomers.add(acc.Id);  
    }
     
    //This logic is only for business accounts  
    if(businessCustomers.size() > 0){       
        Set <Id> newNodesForPortalCustomers = new Set<Id>();
        List <Account> accounts = new List<Account>();
        
        for(Account acc: [Select Id, Type, HierarchyCustomerNumber__c, KISS_Customer_No__c,Customer_No__c, IsPersonAccount, Parent.Id, SuperiorAccount__c from Account where Id IN : businessCustomers]){                     
            //Due to requirements added by Anders Lundmark, hierarhy customers must have Kiss customer number equal to autogenerated hierarchy id (See SF-230), but only if Kiss customer number is null               
            
            if(acc.Type == 'Hierarki'){
                boolean updateAccount = false;
                //T1+T2: Account is cloned to allow update to KISS_Customer_No__c
                Account tmp = acc.clone(true, true);            
                //T1: KISS_Customer_No__c is the main key used in integration
                if (acc.KISS_Customer_No__c == null || acc.KISS_Customer_No__c == ''){
                    tmp.KISS_Customer_No__c = acc.HierarchyCustomerNumber__c;
                    updateAccount = true;
                }                   
                //T2: Customer_No__c is not critical but we update the field to ensure that HierarchyCustomerNumber__c is displayed consistently in search layout.
                if (acc.Customer_No__c == null || acc.Customer_No__c == ''){
                    tmp.Customer_No__c = acc.HierarchyCustomerNumber__c;
                    updateAccount = true;                   
                }
                if(updateAccount == true)               
                    accounts.add(tmp);
            }
                
            //B1: Cast Iron is bypassed when reparenting business customers  , Commented for SF-1364 
            //if(UserInfo.getUserId() != CastIron.Id){  
            if(UserInfo.getUserId() != userDataLoadId && UserInfo.getUserId() != userCIId && UserInfo.getUserId() != userAPIId){	              
                if(Trigger.isUpdate){                   
                    //T3: Handle automatic uddating of superiorAccount when parent is added or changed
                    if (acc.ParentId != null && Trigger.oldMap.get(acc.Id).ParentId != acc.ParentId){
                            newNodesForPortalCustomers.add(acc.Id);                                                
                     }                     
                }
                //T4: Adds new roles to new cable units or hierarchy customers added to existing hierarchy 
                else if(Trigger.isInsert && !newNodesForPortalCustomers.contains(acc.Id) && acc.ParentId != null){                          
                    newNodesForPortalCustomers.add(acc.Id);
                }                  
             }//Ends if not NON API User             
          }//End for-structure         
          
           //T3+T4: Future calls implemented with guards to avoid incorrect invocation from future and recursive call etc. commented for SF-1364
           //if(newNodesForPortalCustomers.size() > 0 && !System.isFuture() && !System.isBatch() && !System.isScheduled() && UserInfo.getUserId() != CastIron.Id && !RecursionControl.runonce){                                        
           
           // Code Changes for SF-1364
           if(newNodesForPortalCustomers.size() > 0 && !System.isFuture() && !System.isBatch() && !System.isScheduled() && UserInfo.getUserId() != userDataLoadId && UserInfo.getUserId() != userCIId && UserInfo.getUserId() != userAPIId && !RecursionControl.runonce){
               //The try clause is to prevent limit exceptions from occuring if methods are invoked more than 200 times a day for same user.
               try{
                    clsAsyncMethods.addUserRoles(newNodesForPortalCustomers);                   
               }catch(Exception e) {
                    system.debug('Exception caught while invoking future methods: ' + e.getMessage());
               }
           }
           //Update list of updated hierarchy accounts
           if(accounts.size() > 0)
                Database.update(accounts);     
       }//End if business customer

    // Permission Check section ->
    if (Trigger.isUpdate) {
        List<Permission_Check__c> toCreateList = new List<Permission_Check__c>();
        // Accounts where Permission value has changed from 'Ja'
        Map<Id, Account> fromJaMap = new Map<Id, Account>();
        Id fromJaAccId = null;
        // Accounts where Permission value has changed into 'Ja'
        Map<Id, Account> intoJaMap = new Map<Id, Account>();
        Id intoJaAccId = null;
        // Collect all Accounts where Permission value has changed from 'Ja' or into 'Ja'
        for (Account acc : Trigger.New) {
            String oldPermission = Trigger.oldMap.get(acc.Id).Permission__c;
            if (acc.Permission__c != 'Ja' && oldPermission == 'Ja') {
                fromJaMap.put(acc.Id, acc);
                fromJaAccId = acc.Id;
            } else if (acc.Permission__c == 'Ja' && oldPermission != 'Ja') {
                intoJaMap.put(acc.Id, acc);
                intoJaAccId = acc.Id;
            }
        }
        if (fromJaMap.size() > 0 || intoJaMap.size() > 0) {
            // Get the number of days from custom settings
            String numDays = '30'; // default value
            YouSeeCustomSettings__c rec = YouSeeCustomSettings__c.getValues('PermissionCheck_Days');
            if (rec != null && rec.Setting_Value__c != null) {
                numDays = rec.Setting_Value__c;
            }

            // Process all Accounts where Permission value has changed into 'Ja'
            if (intoJaMap.size() > 0) {
                // Check if the trigger was fired multiple times
                List<Permission_Check__c> dbPchs = [
                    SELECT Permission__c
                    FROM Permission_Check__c WHERE Account__c = :intoJaAccId ORDER BY Name DESC LIMIT 1
                ];
                if ((dbPchs.size() > 0) && dbPchs[0].Permission__c) {
                    // The most recent record has Permission__c set to True for an Account to process
                    // - the trigger was fired multiple times
                } else {
                    // Get Yes->No transitions within last numDays for all Accounts in a single query
                    String ids = '(\'';
                    for (Id accId : intoJaMap.keySet()) {
                        ids += (ids.length() > 2) ? (',\'' + accId) : accId;
                        ids += '\'';
                    }
                    ids += ')';
                    List<Permission_Check__c> pchs = Database.query(
                        'SELECT Account__c FROM Permission_Check__c ' +
                        'WHERE Account__c IN ' + ids + ' AND Permission__c=FALSE AND LastModifiedDate=LAST_N_DAYS:' + numDays
                    );
                    for (Account acc : intoJaMap.values()) {
                        // Was there a Yes->No transition within last numDays for the given Account?
                        Boolean wasTx = false;
                        for (Permission_Check__c pch : pchs) {
                            if (pch.Account__c == acc.Id) {
                                wasTx = true;
                                break;
                            }
                        }
                        // Create a new PermissionCheck record for Account where Permission value has changed into 'Ja'
                        Permission_Check__c pch = new Permission_Check__c();
                        pch.Account__c = acc.Id;
                        pch.Permission__c = true;
                        pch.Permission_Check_Timestamp__c = wasTx ? acc.LastModifiedDate : null;
                        pch.User_Id__c = acc.LastModifiedById;
                        toCreateList.add(pch);
                    }
                }
            }

            // Process all Accounts where Permission value has changed from 'Ja'
            if (fromJaMap.size() > 0) {
                // Check if the trigger was fired multiple times
                List<Permission_Check__c> dbPchs = [
                    SELECT Permission__c
                    FROM Permission_Check__c WHERE Account__c = :fromJaAccId ORDER BY Name DESC LIMIT 1
                ];
                if ((dbPchs.size() > 0) && !dbPchs[0].Permission__c) {
                    // The most recent record has Permission__c set to False for an Account to process
                    // - the trigger was fired multiple times
                } else {
                    // Get No->Yes transitions within last numDays for all Accounts in a single query
                    String ids = '(\'';
                    for (Id accId : fromJaMap.keySet()) {
                        ids += (ids.length() > 2) ? (',\'' + accId) : accId;
                        ids += '\'';
                    }
                    ids += ')';
                    List<Permission_Check__c> pchs = Database.query(
                        'SELECT Account__c, User_Id__c FROM Permission_Check__c ' +
                        'WHERE Account__c IN ' + ids + ' AND Permission__c=TRUE AND LastModifiedDate=LAST_N_DAYS:' + numDays
                    );
                    for (Account acc : fromJaMap.values()) {
                        // Was there a No->Yes transition by the same user within last numDays for the given Account?
                        Boolean wasTx = false;
                        for (Permission_Check__c pch : pchs) {
                            if (pch.Account__c == acc.Id && pch.User_Id__c == acc.LastModifiedById) {
                                wasTx = true;
                                break;
                            }
                        }
                        // Create a new PermissionCheck record for Account where Permission value has changed from 'Ja'
                        Permission_Check__c pch = new Permission_Check__c();
                        pch.Account__c = acc.Id;
                        pch.Permission__c = false;
                        pch.Permission_Check_Timestamp__c = wasTx ? acc.LastModifiedDate : null;
                        pch.User_Id__c = acc.LastModifiedById;
                        toCreateList.add(pch);
                    }
                }
            }
        }
        if (toCreateList.size() > 0) {
            // Insert all new PermissionCheck records
            Database.insert(toCreateList);
        }
    }
    // <- Permission Check section
}//End class

/* Old version where customer hierarchy is updated with future method.
trigger tgrAccountAfterInsertUpdate on Account (after insert, after update) {
    //B1. Retrieve ID for Cast Iron User for bypassing validation.    
    public static User CastIron = [Select ID from User where Name= 'CI CastIron' limit 1];
    
    //Retrieve Salesforce ids for Service-Center profiles
    //private static String portalUserRoleId = ServiceCenter_CustomSettings__c.getInstance('Selvbetjeningsbruger') != null ?  ServiceCenter_CustomSettings__c.getInstance('Selvbetjeningsbruger').Value__c : null;
    //private static String portalUserAdministratorRoleId = ServiceCenter_CustomSettings__c.getInstance('Selvbetjeningsadministrator') != null ? ServiceCenter_CustomSettings__c.getInstance('Selvbetjeningsadministrator').Value__c : null;
    
    Set<Id> businessCustomers = new Set<Id>();
    for(Account acc: Trigger.new) {
        //Collecting necessary ids for validation purposes - business customers only
        if(!businessCustomers.contains(acc.Id) && acc.IsPersonAccount == false)
            businessCustomers.add(acc.Id);  
    }
     
    //This logic is only for business accounts  
    if(businessCustomers.size() > 0){
        Set<Id> accountHierarchyUpdate_sc1 = new Set<Id>();
        Set<Id> accountHierarchyUpdate_sc2 = new Set<Id>();
        Set<Id> accountHierarchyUpdate_sc3 = new Set<Id>();
        Set <Id> newNodesForPortalCustomers = new Set<Id>();
        List <Account> accounts = new List<Account>();
        
        for(Account acc: [Select Id, Type, HierarchyCustomerNumber__c, KISS_Customer_No__c,Customer_No__c, IsPersonAccount, Parent.Id, SuperiorAccount__c from Account where Id IN : businessCustomers]){                     
            //Due to requirements added by Anders Lundmark, hierarhy customers must have Kiss customer number equal to autogenerated hierarchy id (See SF-230), but only if Kiss customer number is null               
            
            if(acc.Type == 'Hierarki'){
                boolean updateAccount = false;
                //T1+T2: Account is cloned to allow update to KISS_Customer_No__c
                Account tmp = acc.clone(true, true);            
                //T1: KISS_Customer_No__c is the main key used in integration
                if (acc.KISS_Customer_No__c == null || acc.KISS_Customer_No__c == ''){
                    tmp.KISS_Customer_No__c = acc.HierarchyCustomerNumber__c;
                    updateAccount = true;
                }                   
                //T2: Customer_No__c is not critical but we update the field to ensure that HierarchyCustomerNumber__c is displayed consistently in search layout.
                if (acc.Customer_No__c == null || acc.Customer_No__c == ''){
                    tmp.Customer_No__c = acc.HierarchyCustomerNumber__c;
                    updateAccount = true;                   
                }                               
                if(updateAccount == true)               
                    accounts.add(tmp);
            }  
            
            //B1: Cast Iron is bypassed when reparenting business customers            
            if(UserInfo.getUserId() != CastIron.Id){                
                if(Trigger.isUpdate){
                    /*If any updates to parent field then add account to async update queue.
                      Important. We only update if account has childs for performance purposes. For customers with no childs, necessary updates to superiorAccount are performed in tgrAccountBeforeInsert
                        Two scenarios can occur when updating parent:
                            1) Node was topmost node before change. Now a new parent has been added. Based on this knowledge we can update all related childs to new parent.
                            2) Node was not topmost node before change. Now a new parent has been added. Update the superioraccount on this node and all related childs to new parent.                          
                            3) Node was not the topmost node before change. Now the node is the the topmost parent. Update all related childs setting their superioraccount to this node.
                            4) New customer is added with a parent value. We use this to only add any user related roles, if necessary.
                    */
                    /*
                    //T3: Handle automatic uddating of superiorAccount when parent is added or changed
                    if (Trigger.oldMap.get(acc.Id).ParentId != acc.ParentId &&
                         acc.SuperiorAccount__c != acc.ParentId){
                         //Scenario 1               
                         if(Trigger.oldMap.get(acc.Id).ParentId == null && acc.ParentId != null && !accountHierarchyUpdate_sc1.contains(acc.Id))                            
                            accountHierarchyUpdate_sc1.add(acc.Id);                        
                         //Scenario 2
                         else if(Trigger.oldMap.get(acc.Id).ParentId != null && acc.ParentId != null && !accountHierarchyUpdate_sc2.contains(acc.Id))                            
                            accountHierarchyUpdate_sc2.add(acc.Id);
                         //Scenario 3
                         else if(Trigger.oldMap.get(acc.Id).ParentId != null && acc.ParentId == null && !accountHierarchyUpdate_sc3.contains(acc.Id))                            
                            accountHierarchyUpdate_sc3.add(acc.Id);                         
                     }                     
                }
                //T4: Adds new roles to new cable units or hierarchy customers added to existing hierarchy                      
                if(Trigger.isInsert && !newNodesForPortalCustomers.contains(acc.Id)){                           
                    newNodesForPortalCustomers.add(acc.Id);
                }                      
             }//Ends if not Cast Iron             
          }//End for-structure
          
           //T3+T4: Future calls implemented with guards to avoid incorrect invocation from future and recursive call etc.
           if(!System.isFuture() && !System.isBatch() && !System.isScheduled() && UserInfo.getUserId() != CastIron.Id && !RecursionControl.runonce){                                        
               //The try clause is to prevent limit exceptions from occuring if methods are invoked more than 200 times a day for same user.
               try{
                    //Call async method for updating customer hierarchy - Scenario 1
                   if(accountHierarchyUpdate_sc1.size() > 0)
                         clsAsyncMethods.updateAccountHierarchy_Parent_Update(accountHierarchyUpdate_sc1, true, false);
                   //Call async method for updating customer hierarchy - Scenario 2
                   else if(accountHierarchyUpdate_sc2.size() > 0)
                        clsAsyncMethods.updateAccountHierarchy_Parent_Update(accountHierarchyUpdate_sc2, true, false);
                   
                   //Call async method for updating customer hierarchy - Scenario 2
                   else if(accountHierarchyUpdate_sc3.size() > 0)
                        clsAsyncMethods.updateAccountHierarchy_Parent_Update(accountHierarchyUpdate_sc3, false, false);
                   
                   //Call async method for adding user roles - scenario 4
                   else if(newNodesForPortalCustomers.size() > 0)
                        clsAsyncMethods.updateAccountHierarchy_Parent_Update(newNodesForPortalCustomers, false, true);
               }catch(Exception e) {
                    system.debug('Exception caught while invoking future methods: ' + e.getMessage());
               }
           }           
                           
           //Update list of updated accounts
           if(accounts.size() > 0)
                Database.update(accounts);       
       }//End if after
}
*/